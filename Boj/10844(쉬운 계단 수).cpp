#include <iostream>
using namespace std;
const int MOD = 1000000000;
int d[101][11], n;
int main() {
	cin >> n;
	for(int i = 1; i <= 9; ++i)
		d[1][i] = 1;

	for(int i = 2; i <= n; ++i) {
		d[i][0] = d[i - 1][1];
		for(int j = 1; j <= 9; ++j) {
			d[i][j] = (d[i - 1][j - 1] + d[i - 1][j + 1]) % MOD;
		}
	}
	int sum = 0;
	for(int i = 0; i < 10; ++i)
		sum = (sum + d[n][i]) % MOD;

	cout << sum;
}

//설명
//쉬운계단수는 언뜻보면 어려워 보이지만 규칙을 알면
//쉽게 접근할 수 있다.
//2자리 이상의 계단수가 되려면
//K번째 계단수의 첫번째 숫자가 N이면
//N뒤에 올 수 있는 숫자는 D[K-1][N-1] 과 D[K-1][N+1]이다
//
//그리고 예외를 1~8과 9로 나눌 수 있는데
//1은 작은 숫자인 0이 존재하지만 9보다 큰 숫자는 존재하지 않는다는점을 유의하자.
//메모이제이션의 범위를 1~9보다 크게 잡아서 소스량을 줄였다.
//하지만 예외를 직접 처리해주는게 보다 효율적인 프로그램이 된다.