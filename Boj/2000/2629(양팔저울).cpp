#include <bits/stdc++.h>
using namespace std;
const int M = 15e3 + 1;
int wei[31];
bool dp[M], after[M];
int main() {
	int c;
	scanf("%d", &c);
	for(int i = 0; i < c; ++i) {
		scanf("%d", &wei[i]);
	}

	dp[0] = after[0] = true;
	for(int i = 0; i < c; ++i) {
		for(int j = 0; j < M; ++j) {
			if(dp[j]) {
				int b = abs(j - wei[i]);
				after[j + wei[i]] = true;
				after[b] = true;

                // 경우2
				if(b <= j)
					dp[b] = true;
			}
            // 경우1
			if(after[j]) {
				dp[j] = true;
			}
		}
	}

	int tc, num;
	scanf("%d", &tc);
	while(tc--) {
		scanf("%d", &num);
		printf("%c ",  num < M && dp[num] ? 'Y' : 'N');
	}
	puts("");
}

// 설명(DP)
// 무게추로 만들 수 있는 조합을 구해야 한다.
// 핵심은 구해진 조합을 처리 하는 방법이다.
// 처음에 2차원 DP를 생각 했었으나, 코드 처리 하는 부분이 너무 어지러워 접고
// after 배열을 하나 만들어서 처리 해줬다.

// ex)
// 5
// 2 5 7
// 이라는 케이스가 있다고 해보자.(기저 단위로 DP배열의 0은 트루이다)
// 1번추 2
// DP =     {0}  {0}     {0, 2}
// after =  {0}  {0, 2}  {0, 2}
// 2번추 (-3) 2 (5) 7
// 2번추를 계산할때 문제가 되는 부분은 |-3| 과 5 이다.
// 만들수 있는 값이라고 무조건 after 배열에 추가 하면 안된다.

// 경우1. 현재 만들수 있는 값 이 체크중인 값 보다 클때
// 경우2. 현재 만들수 있는 값 이 체크중인 값 보다 작을때

// 1번의 경우는 after 배열에 추가하고 탐색중인 값에 도착했을때 DP배열에 갱신하면 된다.
// 2번의 경우는 바로 DP배열에 갱신하면 된다.

// 그럼 다시 돌아와서 순서를 보면
// DP =    { 0, 2 }  {0, 2}     {0, 2}           {0, 2, 3}        {0, 2, 3, 5}     {0, 2, 3, 5, 7}
// after = { 0, 2 }  {0, 2, 5}  {0, 2, 3, 5, 7}  {0, 2, 3, 5, 7}  {0, 2, 3, 5, 7}  {0, 2, 3, 5, 7}

// 이렇게 만들어 진다. 만들어진 금액을 탐색하는 두번째 포문이 만들어진 금액에 도달하기 전까지는
// 절대 DP배열에 갱신하지 않는다.