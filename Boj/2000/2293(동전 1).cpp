#include <bits/stdc++.h>
using namespace std;
int n, k, coin[101], dp[10001];
int main() {
	cin >> n >> k;
	for(int i = 0; i < n; ++i)
		cin >> coin[i];
	dp[0] = 1;
	for(int i = 0; i < n; ++i) {
		for(int j = 1; j <= k; ++j) {
			if(j - coin[i] >= 0) {
				dp[j] += dp[j - coin[i]];
			}
		}
	}
	cout << dp[k];
}

// 설명(DP)
// N가지 종류의 동전을 적절히 더해 K원이 되는 경우의 수를 구하는 문제이다.

// 1,2,5원이 있다고 가정하고 10원을 만들 수 있는 경우의 수는 어떻게될까?
// 1원 = 1
// 2원 = 1 + 1, 2
// 3원 = 1 + 1 + 1, 2 + 1
// 4원 = 2 + 2, 1 + 1 + 2, 1 + 1 + 1 + 1
// 5원 = 1 + 1 + 1 + 1 + 1,
//		 2 + 1 + 1 + 1
//		 2 + 2 + 1
//		 2 + 2

// 이렇게 될 것이다. 그렇다면 점화식은 어떻게 만들어야 할까? 우선 dp[0] = 1로 초기화 해둘 필요가 있다.
// dp[만들고자 하는 J원] += dp[만들고자 하는 J원 - 동전] 글로 표현하면 이렇게 될것 같다.
// dp[만들고자 하는 J원 - 동전] 이건 무슨 뜻일까?
// 조금 풀어서 설명을 하면 만들어져 있는 X원에 동전 K를 더했을때 만들 수 있는 값이 되는 것이다.
// 위의 케이스를 토대로 설명을 더해보면,

// DP	1	2	3	4
// 1원	1	1	1	1
// 2원	1	2	2	2
// 4원	1	2	2	3

// 이렇게 순차적으로 쌓이게 된다.
// 표를 그려보면 좀 더 쉽게 설명이 되는데 글로 풀어서 쓰려니 힘들다.