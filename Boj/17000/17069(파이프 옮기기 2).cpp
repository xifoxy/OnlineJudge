#include <bits/stdc++.h>
using namespace std;
struct info{
    int x, y, dir;
}; 
const int M = 40;
int dx[]{0,1,1};
int dy[]{1,1,0};
int board[M][M];
long long dp[M][M][3];
int n;

// 충돌체크 함수
bool safe(int x, int y){
    return x >= 0 && y >= 0 && x < n && y < n && !board[x][y];
}

// 파이프가 향한 방향에 따라서 탐색할 방향 리턴
vector<int> get_direction(int dir){
    if(!dir) return {0,1};
    if(dir == 1) return {0,1,2};
    return {1,2};
}

// 솔루션
long long sol(int x, int y, int dir){
    // 도착했으면 1을 반환.
    if(x == n - 1 && y == n - 1) return 1;

    // -1이 아니라면 이미 방문 했다는 뜻이다.
    // 그러니 바로 리턴해주면 된다.
    long long &ret = dp[x][y][dir];
    if(ret != -1) return ret;

    // 탐색 방향을 받아와서
    vector<int> direction = get_direction(dir);

    // 방문했다는 표기를 해주고,
    ret = 0;

    // 탐색
    for(auto &idx : direction){
        int nx = x + dx[idx];
        int ny = y + dy[idx];
        // 가로와 세로는 파이프 헤드만 전진하기 때문에 따로 체크 해줄 필요 없다.
        if(safe(nx,ny)){
            // 파이프가 대각선으로 이동할 경우를 생각해봐야 한다.
            // 대각선으로 이동하게 되면 바디가 될 위치의 →,↓도 차지하게 된다.
            // 그러니 대각선일 경우 좌표 검사가 한번 더 필요하다.
            if(idx == 1){
                if(safe(x + 1, y) && safe(x,  y + 1))
                    ret += sol(nx, ny, idx);
            } else ret += sol(nx, ny, idx);
        }
    }
    return ret;
}

int main(){
    // 메모이제이션 배열 초기값은 -1로 한다.
    memset(dp, -1, sizeof(dp));
    scanf("%d", &n);
    for(int x = 0; x < n; ++x){
        for(int y = 0; y < n; ++y){
            scanf("%d", &board[x][y]);
        }
    }
    // 0,0은 바디이다
    // 움직이기 시작할 부분은 헤드부분인 0,1좌표이다.
    printf("%lld", sol(0,1,0));
}

// 설명(DP)
// 우선 탐색 기반은 BruteForce이다.
// 모든 경우를 다 따져 보려면 못해도 최소 2^32~에서.. 얼마나 더 해야하지..?
// 아무튼 0.5초안에 해결하기에는 불가능한 규모다.
// 그렇다면 우선 완전탐색 기반으로 설계를 하고, 불필요한 중복방문에 대한것을 메모이제이션 해야할 필요가 있다.


//#############################################################################################
// 주석에 대부분 설명이 되어 있지만, 메모이제이션 배열이 3차원인 이유에 대해서 더 설명해야 할것 같다.
// 예를 들어서
// 아래와 같이 파이프가 세로로 이동했을때 값이 갱신 되었다고 해보자. Body(2,4) head(3,4)
//  |0 1 2 3 4          |0 1 2 3 4
// -|---------         -|---------
// 0|0 0 0 0 0         0|0 0 0 0 0
// 1|0 0 0 0 0         1|0 0 0 0 0
// 2|0 0 0 0 B         2|0 0 0 0 0
// 3|0 0 0 0 H         3|0 0 B H 1
// 4|0 0 0 0 0         4|0 0 0 0 0

// 첫번째 표에서 [3,4] 에 1이 갱신되고,
// 두번째 표에 대한 상황에 마주하게 된다면... Body(3,2) head(3,3)
// 방향성이 없다면 아래와 같은 상황이 발생한다.

//  |0 1 2 3 4
// -|---------
// 0|0 0 0 0 0
// 1|0 0 0 0 0
// 2|0 0 0 0 0
// 3|0 0 0 2 1
// 4|0 0 0 0 0
// ## 2가 갱신되는 이유(head좌표가 [4,4]를 만난것과 [3,4]를 만난것을 갱신. 후자가 오류)
// 그러니 방향성에 따라서 메모이제이션 해줄 필요가 있다.