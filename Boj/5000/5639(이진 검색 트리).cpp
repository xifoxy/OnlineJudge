#include <bits/stdc++.h>
using namespace std;
const int MAX = 1e4 + 1;
int d[MAX], num, idx;
void sol(int left, int right) {
	int next = left;
	 for(int i = left; i <= right; ++i) {
		if(d[i] > d[next]) {
			next = i - 1;
			break;
		}
	}
	if(next != left) sol(left + 1, next);
	if(next != right) sol(next + 1, right);
	printf("%d\n", d[left]);
}
int main() {
	while(scanf("%d", &num) != EOF) {
		d[idx++] = num;
	}
	sol(0, idx - 1);
}

//설명
//이 문제는 그림을 그려야 한다...
//테케로 간략하게 설명을 하자면 잘 자르면 된다.
//전위는 루트->왼->오
//후위는 왼->오->루트
//전위는 루트가 가장 먼저 출력되니까 후위순위로 뒤집으려면 루트를 가장 마지막에 출력해주면 된다.
//문제 조건에서 왼쪽자식은 작은숫자, 오른쪽 자식은 큰숫자라는 대소관계가 뚜렷하기 때문에
//루트보다 큰 숫자를 만나는지점에서 자르면 왼쪽과 오른쪽의 서브트리를 구할수가 있다.
//큰 숫자가 없다면 그 루트를 제외한 숫자는 왼쪽 서브트리가 된다.

//테케를 살펴보자.
//[50] 30 24 5 28 45 | [98] 52 60
//98이라는 기점으로 오른쪽과 왼쪽의 서브트리가 나뉜다.
//[30] 24 5 28 | [45](더이상 자를게 없다)
//이건 45
//[24] 5 | [28](더이상 자를게 없다)
//이건 28
//[5]
//이렇게 더이상 자를게 없을때 루트를 루트를 출력해주면
//5->28->24->45->30
//전체 트리에서 왼쪽 서브트리의 후위검색을 구했다.
//오른쪽 서브트리도 똑같이 작업해주고 루트를 출력하면
//[98] 52 60
//[52] | [60]
//52->60->98
//두개를 합치면
//5->28->24->45->30->52->60->98->루트(50)