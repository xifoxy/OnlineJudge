#include <bits/stdc++.h>
using namespace std;
long long dp[65][10];
int main() {
    // for(int i = 0; i < 10; ++i) {
    //     dp[0][i] = 1;
	// }

	// for(int i = 1; i < 64; ++i) {
	// 	for(int j = 0; j < 10; ++j) {
	// 		for(int k = j; k < 10; ++k) {
	// 			dp[i][j] += dp[i - 1][k];
	// 		}
	// 	}
	// }

    for(int i = 1; i < 65; ++i) {
	    dp[i][0] = 1;
        for(int j = 1; j < 10; ++j) {
			dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
		}
	}

	int tc;
	scanf("%d", &tc);
	while(tc--) {
		int n;
		long long sum = 0;
		scanf("%d", &n);
		for(int i = 0; i < 10; ++i) {
			sum += dp[n][i];
		}
		printf("%lld\n", sum);
	}
}

// 설명(Dp)
// 문제에서 줄어들지 않는 수의 조건은 자릿수가 뒤쪽으로 갈 수록 크거나 같아야 한다는 것이다.
// ex)
// 0000, 0001, 0002
// 0011, 1111, 1112, 1122, 2223

// 그럼 문제에 주어진 조건대로 점화식을 만들어 보겠다.
// 우선 한자리로 된 수는 전부다 "줄어들지 않는 수" 이다.
// dp[1][x] = 0, 1, 2, 3, 4, 5, 6, 7, 8, 9


// 그럼 두번째 자릿수 부터는?
// dp[2][1] = 0,[1, 2, 3, 4, 5, 6, 7, 8, 9]
// dp[2][2] = 0, 1,[2, 3, 4, 5, 6, 7, 8, 9]
// dp[2][3] = 0, 1, 2,[3, 4, 5, 6, 7, 8, 9]
// dp[2][4] = 0, 1, 2, 3,[4, 5, 6, 7, 8, 9]
// dp[2][5] = 0, 1, 2, 3, 4,[5, 6, 7, 8, 9]
// dp[2][6] = 0, 1, 2, 3, 4, 5,[6, 7, 8, 9]
// dp[2][7] = 0, 1, 2, 3, 4, 5, 6,[7, 8, 9]
// dp[2][8] = 0, 1, 2, 3, 4, 5, 6, 7,[8, 9]
// dp[2][9] = 0, 1, 2, 3, 4, 5, 6, 7, 8,[9]

// 이렇게 현재 자릿수와 크거나 같아야 하기 때문에 해당 범위의 값들을 전부 더해주면 된다.
// 식을 만들어보면 아래와 같은 식이 될것이다.
// for(int i = 0; i < 10; ++i) {
//     dp[0][i] = 1;
// }

// for(int i = 1; i < 64; ++i) {         // 현재 자릿수
//     for(int j = 0; j < 10; ++j) {     // 현재 위치
//         for(int k = j; k < 10; ++k) { // 현재 위치보다 크거나 같은 수들
//             dp[i][j] += dp[i - 1][k];
//         }
//     }
// }

// 여기 까지는 있는 그대로 구현한것이고, 이 식을 살짝 뒤집으면 식이 간소화 된다.
// 답에서 요구하는 사항은 주어진 자릿수의 오른차순으로(같거나 큰)이루어진 수들의 갯수만을
// 출력하면 되기 때문에 
// dp[2][1] = 0, [1, 2, 3, 4, 5, 6, 7, 8, 9]	 ==>	 dp[2][9] = 0, [1, 2, 3, 4, 5, 6, 7, 8, 9]
// dp[2][2] = 0, 1, [2, 3, 4, 5, 6, 7, 8, 9]	 ==>	 dp[2][8] = 0, 1, [2, 3, 4, 5, 6, 7, 8, 9]
// dp[2][3] = 0, 1, 2, [3, 4, 5, 6, 7, 8, 9]	 ==>	 dp[2][7] = 0, 1, 2, [3, 4, 5, 6, 7, 8, 9]
// dp[2][4] = 0, 1, 2, 3, [4, 5, 6, 7, 8, 9]	 ==>	 dp[2][6] = 0, 1, 2, 3, [4, 5, 6, 7, 8, 9]
// dp[2][5] = 0, 1, 2, 3, 4, [5, 6, 7, 8, 9]	 ==>	 dp[2][5] = 0, 1, 2, 3, 4, [5, 6, 7, 8, 9]
// dp[2][6] = 0, 1, 2, 3, 4, 5, [6, 7, 8, 9]	 ==>	 dp[2][4] = 0, 1, 2, 3, 4, 5, [6, 7, 8, 9]
// dp[2][7] = 0, 1, 2, 3, 4, 5, 6, [7, 8, 9]	 ==>	 dp[2][3] = 0, 1, 2, 3, 4, 5, 6, [7, 8, 9]
// dp[2][8] = 0, 1, 2, 3, 4, 5, 6, 7, [8, 9]	 ==>	 dp[2][2] = 0, 1, 2, 3, 4, 5, 6, 7, [8, 9]
// dp[2][9] = 0, 1, 2, 3, 4, 5, 6, 7, 8, [9]	 ==>	 dp[2][1] = 0, 1, 2, 3, 4, 5, 6, 7, 8, [9]

// 이런식으로 인덱스로 장난을 치면 구조가 Prefix sum으로 변형되게 된다.

// for(int i = 1; i < 65; ++i) {
//     dp[i][0] = 1;
//     for(int j = 1; j < 10; ++j) {
//         dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
//     }
// }