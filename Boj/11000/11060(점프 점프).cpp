#include <bits/stdc++.h>
using namespace std;
const int M = 1e3 + 1;
int jump[M], dp[M], n;
int main() {
	scanf("%d", &n);
	for(int i = 0; i < n; ++i) {
		scanf("%d", &jump[i]);
		dp[i] = M;
	}

	dp[0] = 0;
	for(int i = 0; i < n; ++i) {
		for(int j = i + 1; j <= jump[i] + i; ++j) {
			if(j == n) break;
			if(dp[j] > dp[i] + 1)
				dp[j] = dp[i] + 1;
		}
	}
	printf("%d\n", dp[n - 1] == M ? -1 : dp[n - 1]);
}

// (나만 알아봄)
// 0으로 초기화된 배열가지고 제출해서 몇번 틀렸다.
// 거기에 썼던 점화식은 !dp[j] || dp[i] + 1 < dp[j]
// 이렇게하면 시작점이 0이어도 무조건 갱신하기 때문에 오답이 나온다.

// 설명(DP)
// 시작점을 0으로 초기화 해놓고 나머지는 충분히 큰 숫자로(나올수 없는 답)
// 으로 초기화 한다. 그리고 점프 할 수 있는지? 에 대해서 dp배열을 갱신하면 된다.

// example)
// 5
// 0 1 2 3 4
// 이 경우 시작점을 0으로 초기화 하면 나머지 1~4 구간은
// 갱신되지 않는다. jump[0]이 0이기 때문에  두번째 포문에 들어갈 수 조차 없기 때문이다.

// 10
// 1 2 0 1 3 2 1 5 4 2
// 0 1 2 2 3 4 4 4 5 5
// dp배열이 갱신되는 숫자이다.
// 조건식에 따라 갱신되는 숫자를 어렵지않게 추론할 수 있다.